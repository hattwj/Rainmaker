from queue import Queue
import random
import traceback

from warnings import warn
from threading import RLock, Timer
import traceback

import ujson

from rainmaker.net.utils import RTimer, LStore
from rainmaker.net.errors import EventError, AuthConfigError

class ParamsBase(object):
    _type = dict

    def __init__(self, data=None):
        super(ParamsBase, self).__init__()
        self.data = self._type() if data is None else data
        if not type(self.data) is self._type:
            raise EventError('Not a %s: %s' % (self._type, repr(self.data)))
        self.akeys = set()
        self.rkeys = set()

    def __repr__(self):
        ''' Fancy lookin repr '''
        try:
            return '<%s data={%s}>' % (self.__class__.__name__, ', '.join(['%s:%s' % (k, v) for k, v in self.data.items()]))
        except TypeError as e:
            return super(Params, self).__repr__()

    def require(self, *keys):
        '''Require these keys'''
        self.rkeys.update(keys)
        return self

    def allow(self, *keys):
        '''Allow these keys'''
        self.akeys.update(keys)
        return self

    def val(self, key=None, cls=None):
        '''get req/allow keys or key and return them'''
        try:
            return self._val(key, cls)
        except KeyError as e:
            raise EventError('Required key missing: %s' % key) from e
        except TypeError as e:
            raise EventError('Bad type on val: %s' % type(self.data)) from e
    
    def pluck(self, *keys):
        '''
            Return an array of required vals
        '''
        try:
            return [self.data[x] for x in keys]
        except KeyError as e:
            raise EventError('Required key missing: %s' % x) from e
        except TypeError as e:
            raise EventError('Bad type on val: %s' % type(self.data)) from e

    def _val(self, key=None, cls=None):
        if key is not None:
            return self.data[key]
        if not self.akeys and not self.rkeys:
            return self.data
        return self._filter_dict(self.data)

    def _filter_dict(self, adict):
        result = {}
        for k in self.rkeys:
            try:
                result[k] = adict[k]
            except KeyError as e:
                raise EventError('Required key missing: %s' % k) from e
        for k in self.akeys:
            if k in adict:
                result[k] = adict[k]
        return result

class Params(ParamsBase):
    '''
        Useful class for managing parameters
    '''
    def __init__(self, data=None):
        super(Params, self).__init__(data)

    def aget(self, key):
        return self.get(key, ArrayParams)

    def get(self, key, cls=None):
        ''' Instantiate new class from key and data '''
        cls = cls if cls else Params
        try:
            val = self.data[key]
        except KeyError as e:
            raise EventError('Required key missing: %s' % key) from e
        except TypeError as e:
            raise EventError('Bad type on get: %s' % type(self.data)) from e
        return cls(val)

class ArrayParams(ParamsBase):
    _type = list
    
    def __init__(self, data=None):
        super(ArrayParams, self).__init__(data)

    def _val(self, key=None, cls=None):
        if key:
            raise TypeError('Invalid option: key')
        result = []
        for k in self.data:
            v = self._filter_dict(k) if self.akeys or self.rkeys else k
            v = cls(v) if cls else v
            result.append(v)
        return result

    def get(self):
        return self.val(cls=Params)

class Event(Params):
    '''
        Events that are generated by EventHandler
        - NullSession: localhost
        - ToxSession: tox
    '''
    _attrs = ['name', 'status', 'rcode']
    def __init__(self, name, params=None, status=None, reply=None, error=None, \
            source=None, rcode=0, session=None):
        super(Event, self).__init__(params)
        self.session = session
        self.name = name
        self.status = status if status else 'ok'
        self.source = source
        self.reply_with = reply
        self.error_with = error
        self.rcode = rcode 
    
    def __repr__(self):
        ''' Fancy lookin repr '''
        try:
            return '<%s %s data={%s}>' % (
                    self.__class__.__name__, 
                    ', '.join(['%s:%s' % (k, repr(getattr(self, k))) for k in self._attrs]),
                    ', '.join(['%s:%s' % (k, v) for k, v in self.data.items()])
                )
        except TypeError as e:
            return super(Params, self).__repr__()

    def reply(self, status, params=None):
        '''
            Run reply for this event (if one was specified)
        '''
        if not self.reply_with:
            warn('No "reply_with" specified for: %s' % self.name)
            return
        e = Event(self.rcode, params=params, status=status)
        self.reply_with(e)

class EventHandler(object):
    '''
        Listen for events and call registered functions
    '''
    def __init__(self, parent=None, queue=False, auth_strategy=None):
        self.parent = parent
        self.__cmds__ = LStore()
        self.queue = Queue() if queue else None
        self.__auth_strategy_on = False
        self.auth_strategy = auth_strategy

    def trigger(self, name, params=None, status=None, reply=None, \
            error=None, source=None, rcode=0, session=None):
        '''
            Call all functions for event name
        '''
        source = source if source else self.parent
        event = Event(name, params=params, status=status, reply=reply, \
            error=error, source=source, rcode=rcode, session=session)
        try:
            funcs = self.__cmds__[event.name]
        except KeyError as e: 
            self.handler_missing(event)
            return False 
        if self.queue:
            self.queue.put((funcs, event))
        else:
            self.dispatch(funcs, event)
        return True

    def commit(self):
        '''Run all events in Queue'''
        while True:
            try:
                funcs, event = self.queue.get_nowait()
                self.dispatch(funcs, event)
            except Empty as e:
                break

    def dispatch(self, funcs, event): 
        ''' Run a single event '''
        try:
            for f in funcs:
                if f(event) == False:
                    return False
        except EventError as e:
            warn(traceback.format_exc())
            if event.error_with:
                event.error_with(e)
            return False
        return True

    def handler_missing(self, event):
        '''
            Method called when there are no registered handlers
        '''
        warn('Handler missing: %s' % event.name)

    def temp(self, func, timeout=30):
        ''' Register a temporary function '''
        return self.__cmds__.append([func], timeout=timeout)

    def register(self, name, func, timeout=0):
        '''
            Register func as function to be called when 
            event name is called
        '''
        if self.__auth_strategy_on:
            if self.auth_strategy:
                func = self.auth_strategy(self.parent, func)
            else:
                raise AuthConfigError('No auth strategy specified for: %s' % name) 
        arr = self.__cmds__.get(name, [])
        arr.append(func)
        return self.__cmds__.put(name, arr, timeout=timeout)
 
    def responds_to(self, name, timeout=0):
        '''
            Register Decorator 
        '''
        def wrap(f):
            self.register(name, f, timeout)
        return wrap

    def auth_strategy_on(self):
        ''' Temporarily require all routes that are added to require authentication '''
        self.__auth_strategy_on = True
    
    def auth_strategy_off(self):
        ''' No longer require routes to have authentication '''
        self.__auth_strategy_on = False

