from queue import Queue
import random
from warnings import warn
from threading import RLock, Timer
import traceback

import ujson

class RTimer(object):
    '''
        Generic timer that will run after timeout elapsed
    '''
    def __init__(self, timeout, func, loop=False):
        self.timeout = timeout
        self.func = func
        self.loop = loop
        self._timer = None
        self.ran = False
        self.started = False

    @property
    def running(self):
        '''
            Is the timer running?
        '''
        return self.started and not self.ran

    def reset(self):
        '''
            Reset timer, restart if off
        '''
        self.off()
        self.on()
    
    def _run(self):
        '''
            Run the timer
        '''
        self.func()
        self.ran = True
        if self.loop:
            self.on()

    def on(self):
        '''
            Turn the timer on
        '''
        self._timer = Timer(self.timeout, self._run)
        self._timer.daemon = True
        self._timer.start()
        self.ran = False
        self.started = True
        
    def off(self):
        '''
            Turn the timer off
        '''
        
        self._timer.cancel()

    def is_alive(self):
        return self._timer is not None and self._timer.is_alive()


class EventError(Exception):
    pass

class Params(object):
    '''
        Useful class for managing parameters
    '''
    def __init__(self, data=None):
        self.data = data if data is not None else {}
        self.akeys = set()
        self.rkeys = set()
    
    def __repr__(self):
        ''' Fancy lookin repr '''
        try:
            return '<%s %s>' % (self.__class__.__name__, ', '.join(['%s:%s' % (k, v) for k, v in self.data.items()]))
        except TypeError as e:
            return super(Params, self).__repr__()

    def require(self, *keys):
        '''Require these keys'''
        self.rkeys.update(keys)
        return self

    def allow(self, *keys):
        '''Allow these keys'''
        self.akeys.update(keys)
        return self
            
    def val(self, key=None):
        '''get req/allow keys or key'''
        try:
            if key is not None:
                return self.data[key]
            if not self.akeys and not self.rkeys:
                return self.data
            result = {}
            for k in self.rkeys:
                result[k] = self.data[k]
            for k in self.akeys:
                if k in self.data:
                    result[k] = self.data[k]
            return result
        except KeyError as e:
            raise EventError
        except TypeError as e:
            raise EventError

    def get(self, key):
        ''' Instantiate new from data '''
        try:
            val = self.data[key]
        except KeyError as e:
            raise EventError
        except TypeError as e:
            raise EventError
        return Params(val)

class Event(Params):
    '''
        Events that are generated by EventHandler
    '''
    def __init__(self, name, data):
        super(Event, self).__init__(data)
        self.name = name
        self.status = 'ok'
        self.source = None
        self.reply_with = None
        self.error_with = None

    def serialize(self):
        return ujson.dumps({
            'command': self.name,
            'params': self.val()
        })

    def reply(self, status, data=None):
        if not self.reply_with:
            warn('No "reply_with" specified for: %s' % self.name)
            return
        e = Event('response', data)
        e.status = status
        self.reply_with(e)

class FuncBuffer(object):
    '''
        key/val Function store with timeout
    '''
    int_max = 10**10 

    def __init__(self):
        self.lock = RLock()
        self._buffer = {}

    def rand_key(self):
        '''Generate random unused key'''
        v = None
        while v != True:
            key = random.randint(0, self.int_max)
            v = self._buffer.get(key, True) 
        return key

    def append(self, key, func):
        '''Append Function to dict of arrays'''
        with self.lock:
            if key not in self._buffer:
                self._buffer[key] = []
            self._buffer[key].append(func)            

    def add(self, func, name=None, timeout=0):
        ''' Add function to dict'''
        with self.lock:
            if name is None:
                name = self.rand_key()
            self.append(name,  func)
        if timeout:
            t = Timer(timeout, self.pop, [name])
            t.daemon = True
            t.start()
        return name

    def get(self, key):
        with self.lock:
            return self._buffer[key]

    def pop(self, key):
        with self.lock:
            func = self._buffer.pop(key, None)
        return func

class EventHandler(object):
    '''
        Listen for events and call registered functions
    '''
    def __init__(self, parent, queue=False):
        self.parent = parent
        self.__cmds__ = FuncBuffer()
        self.queue = Queue() if queue else None

    def call_event(self, name, reply=None, error=None, params=None):
        '''
            Call all functions for event name
        '''
        params = params
        event = Event(name, params)
        event.reply_with = reply
        event.error_with = error
        event.source = self.parent
        
        try:
            funcs = self.__cmds__.get(event.name)
        except KeyError as e: 
            self.handler_missing(event)
            return False 

        if self.queue:
            self.queue.put((funcs, event))
        else:
            self.dispatch(funcs, event)
        
        return True

    def commit(self):
        while True:
            try:
                funcs, event = self.queue.get_nowait()
                self.dispatch(funcs, event)
            except Empty as e:
                break

    def dispatch(self, funcs, event):
        
        if event.reply_with:
            self.__cmds__.add(event.reply_with, timeout=30)

        try:
            for f in funcs:
                if f(event) == False:
                    return False
        except EventError as e:
            warn(traceback.format_exc())
            if event.error_with:
                event.error_with(e)
            return False
        return True

    def handler_missing(self, event):
        '''
            Method called when no registered handlers
        '''
        warn('Handler missing: %s' % event.name)

    def register(self, name, func, timeout=0):
        '''
            Register func as function to be called when 
            event name is called
        '''
        return self.__cmds__.add(func, name, timeout)

