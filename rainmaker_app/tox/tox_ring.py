# stdlib imports
from __future__ import print_function
from warnings import warn

# lib imports
from twisted.internet import reactor
from twisted.internet.task import LoopingCall
from pytox import Tox

# local imports
import tox_env
import tox_errors

import json

def parse(line):
    '''
        parse yaml input from tox client
    '''
    print(line)
    try:
        request = json.loads(line)
    except ValueError as e:
        raise tox_errors.ToxCommandError('Failed to parse request')
    if not isinstance(request, dict):
        raise tox_errors.ToxCommandError('Request not a dictionary')
    cmd = request.get('command', None)
    if cmd is None:
        raise tox_errors.ToxCommandError('No command given')
    params = request.get('params', {})
    if not isinstance(params, dict):
        raise tox_errors.ToxCommandError('Params not a dictionary')
    
    return [cmd, params]


class Event(object):
    '''
        Events that are generated by EventHandler
    '''
    def __init__(self, name, params, source=None):
        self.name = name
        self.source = source
        self.params = params

    def serialize(self):
        return json.dumps({
            'command': self.name,
            'params': self.params
        })

class EventHandler(object):
    '''
        Listen for events and call registered functions
    '''
    def __init__(self, parent):
        self.parent = parent
        self.__cmds__ = {}
    
    def call_event(self, name, params):
        '''
            Call all functions for event name
        '''
        event = Event(name, params, self.parent)
        funcs = self.__cmds__.get(name, None)
        if funcs is None:
            self.handler_missing(event)
            return False
        for f in funcs:
            if f(event) == False:
                return False
        return True

    def handler_missing(self, event):
        '''
            Method called when no registered handlers
        '''
        print('no handlers for %s' % event.name)

    def register(self, name, func):
        '''
            Register func as function to be called when 
            name is called
        '''
        if name not in self.__cmds__:
            self.__cmds__[name] = []
        self.__cmds__[name].append(func)

class Timer(object):
    '''
        Generic timer that will run after timeout elapsed
    '''
    def __init__(self, timeout, func, loop=False):
        self.timeout = timeout
        self.func = func
        self.loop = loop
        self._timer = None
        self.ran = False

    @property
    def running(self):
        '''
            Is the timer running?
        '''
        return self._timer.active()

    def reset(self):
        '''
            Reset timer, restart if off
        '''
        self.off()
        self.on()
    
    def _run(self):
        '''
            Run the timer
        '''
        self.func()
        self.ran = True
        if self.loop:
            self.on()

    def on(self):
        '''
            Turn the timer on
        '''
        self._timer = reactor.callLater(self.timeout, self._run)

    def off(self):
        '''
            Turn the timer off
        '''
        if self._timer and self._timer.active():
            self._timer.cancel()

def require_auth(func):
    '''
        Event responder decorator to require auth
    '''
    def wrapper(self, event):
        friend_id = event.params.get('friend_id', None)
        if friend_id is None:
            raise tox_errors.ToxAuthorizationError()
        if friend_id not in self.__authenticated_friends__:
            raise tox_errors.ToxAuthorizationError()
        func(self, event)
    return wrapper
'''
on_search failed
    - set state                   - 0
on_connect_timed_out
    start trying_to_connect       - 1

start:
    start loop
        - runlevels
            0 - stop
            1 - try to connect
                up:
                    conn to rand_server
                    yield  start_conn_wait
                down:
                    stop_conn_wait
                    disconnect
            3 - look for primary
                up:
                    start cc_do_loop
                    yield search 1/0
                down:
                    stop cc_do_loop
                    stop search
            5 - maintain primary
                up: 
                    start cc_do loop
                    yield start maintain loop
                down:
                    stop maintain loop
            6 - cc, do, idle
                up/down: None
'''

class RunLevel(object):

    def __init_vars__(self):
        self.running = False
        self.should_run = True
        self.should_wait = True
        self.valid = False
        self.action = None
        self.prev_action = None

    def __init__(self, name, startf, stopf, is_validf, timeout=30):
        self.name = name 
        self.__start = startf
        self.__stop = stopf
        self.__is_valid = is_validf
        self.__init_vars__()
        self.timeout = timeout
    
    @property
    def status_changed(self):
        return self.prev_action != self.action

    def loop(self):
        self.prev_action = self.action
        self.action = self.__loop__()
        return self.action

    def __loop__(self):
        if self.running and self.should_run:
            if self.is_valid():
                return StateMachine.DO_NEXT
            elif self.should_wait:
                return StateMachine.DO_WAIT
            else:
                self.restart()
                return StateMachine.DID_RESTART
        elif self.running and not self.should_run:
            self.stop()
            return StateMachine.DID_STOP
        elif not self.running and self.should_run:
            self.start()
            return StateMachine.DID_START
        else:
            return StateMachine.DID_NO_OP
    
    def restart(self):
        self.stop()
        self.start()

    def start(self):
        def _stop_waiting():
            self.should_wait = False
        self.should_wait = True
        self.__init_vars__()
        self.__start()
        self.__wait_timer = Timer(self.timeout, _stop_waiting)
        self.__wait_timer.on()
        self.running = True

    def stop(self):
        self.__stop()
        self.__wait_timer.off()
        self.running = False

    def is_valid(self):
        self.valid = self.__is_valid()
        if self.valid and self.__wait_timer.running:
            self.__wait_timer.off()
        elif not self.valid and not self.__wait_timer.running:
            self.__wait_timer.on()
        return self.valid

class StateMachine(object):
    DID_NO_OP   = -1
    DID_STOP    = 0
    DID_START   = 1
    DO_WAIT     = 2
    DID_RESTART = 3
    DO_NEXT     = 4

    IGNORES = [] #[DID_NO_OP, DO_WAIT, DO_NEXT]

    ACTION_NAMES = {
        DID_NO_OP:    'ignoring' ,
        DID_STOP:     'stopping',
        DID_START:    'starting',
        DO_WAIT:      'lost',
        DID_RESTART:  'restarting',
        DO_NEXT:      'completed'
    }

    def __init__(self, wait_time=0.02):
        self.run_levels = []
        self.wait_time = wait_time
        
    def start(self):
        self.stopping = False
        self.do_next = True
        self.__start_loop = LoopingCall(self.__loop__) 
        d = self.__start_loop.start(self.wait_time)
        return d

    def __loop__(self):
        if self.stopping and not self.any_running:
            # were done
            self.__start_loop.stop()
            return
        self.do_next = not self.stopping
        for idx, run_level in enumerate(self.run_levels):
            run_level.should_run = self.do_next 
            action = run_level.loop()
            if run_level.status_changed and not self.level_filter(action):
                self.level_changed(action, run_level.name)
            if action != self.DO_NEXT:
                self.do_next = False
                levels = []
                for jdx, level in enumerate(self.run_levels):
                    if jdx > idx:
                        levels.append(level)
                for level in reversed(levels):
                    level.should_run = False
                    level.loop()
                return
            else:
                self.do_next = True
    
    def level_filter(self, action):
        return action in self.IGNORES

    def level_changed(self, action, name):
        '''
            Override level changed event
        '''
        print('%s %s' % (self.ACTION_NAMES[action], name))

    @property
    def any_running(self):
        for level in self.run_levels:
            if level.running:
                return True
        return False

    def add(self, run_level):
        self.run_levels.append(run_level)

    def stop(self):
        self.stopping = True
    
class ToxBase(Tox):

    '''
        Base class with overrides/defaults for Tox
    '''

    running = False
    was_connected = False
    ever_connected = False

    def __init__(self, data=None):
        self.__authenticated_friends__ = set()
        Tox.__init__(self)
        if data:
            self.load(data)
        # events received from tox client
        self.router = EventHandler(self)
        # events to send up
        self.events = EventHandler(self)
        self.state_machine = StateMachine()
        self.state_machine.add(self.__conn_run_level__())
        self.start = self.state_machine.start
        self.stop = self.state_machine.stop
        
    def __conn_run_level__(self):
        def _start():
            ip, port, pubk = tox_env.random_server()
            self.bootstrap_from_address(ip, port, pubk)
            
        def _stop():
            pass

        def _valid():
            self.do()
            return self.isconnected()
        
        name = 'tox connection'
        run_level = RunLevel(name, _start, _stop, _valid, 30)
        return run_level
          
    def on_read_reciept(self, fno, reciept):
        print('friend: %s recv: %s' % (fno, reciept))

    def on_dht_connected(self):
        print('dht-connnected-event')

    def on_dht_disconnected(self):
        print('dht-disconnected-event')

    def on_friend_request(self, pk, message):
        '''
            Pass to authenticate
        '''
        cmd, params = parse(message)
        params['friend_id'] = None
        params['friend_pk'] = pk
        cmd = 'authenticate'
        self.router.call_event(cmd, params)

    def on_friend_message(self, friend_id, message):
        '''
            A friend has sent a message
        '''
        cmd, params = parse(message)
        params['friend_id'] = friend_id
        self.router.call_event(cmd, params)

    def on_group_message(self, group_number, friend_id, message):
        '''
            A group member sent a message
        '''
        cmd, params = parse(message)
        params['friend_id'] = friend_id
        params['group_number'] = group_number
        self.router.call_event(cmd, params)

    def send_fs_event(self, event):
        '''
            Broadcast fs_event
        '''
        message = event.serialized_params()
        self.group_message_send(self.base_group_id, message)
        raise NotImplementedError('wip') 

class SyncBot(ToxBase):
    '''
        Find primary bot and relay information or bail
        if timeout reached
    '''
    def __init__(self, primary_address, data=None):
        ToxBase.__init__(self, data)
        self.router.register('fs_event', self.__cmd_fs_event__)
        self.router.register('info', self.__cmd_info__)
        self.router.register('authenticate', self.__cmd_authenticate__)
        self.router.register('primary', self.__cmd_primary__)
        self.primary = False
        self.primary_address = primary_address
        self.stop_timer = Timer(tox_env.TIMEOUT, self.stop)
        self.search_timer = Timer(2, self.__search__, loop=True)
        self.state_machine.level_changed = self.state_level_changed

    def state_level_changed(self, code, name):
        print('SyncBot: %s %s' % (StateMachine.ACTION_NAMES[code], name)) 

    def on_dht_connected(self):
        '''
            Enable search/stop timers while connected
        '''
        self.stop_timer.on()
        self.search_timer.on()

    def on_dht_disconnected(self):
        '''
            Disable search/stop timers while disconnected
        '''
        self.stop_timer.off()
        self.search_timer.off()
    
    def on_group_invite(self, friend_num, gtype, grp_pubkey):
        print('Joining group: %s' % gtype)
        group_id = self.join_groupchat(friend_num, grp_pubkey)
        
    def __search__(self):
        '''
            Try to find primary
        '''
        if len(self.get_friendlist()) == 0:
            print('Adding primary')
            self.__request_auth__()
        if self.get_friend_connection_status(0):
            print('Primary found!')
            self.stop_timer.off()
        else:
            if not self.stop_timer.running:
                self.stop_timer.on()
            print('Primary not found')

    def __request_auth__(self):
        msg = Event('authorize', {}).serialize()
        self.add_friend(self.primary_address, msg)

    def stop(self):
        '''
            Stop searching and start primary
        '''
        self.search_timer.off()
        self.on_start_primary()
        super(SyncBot, self).stop()
    
    def on_start_primary(self, event):
        '''
            Overridden in tox_manager
        '''
        raise NotImplementedError('Override this method')
    
    @require_auth
    def __cmd_fs_event__(self, event):
        '''
            Someone had a file_system event
        '''
        pass
    
    @require_auth
    def __cmd_primary__(self, event):
        '''
            Someone thinks we should be primary
        '''
        pass

    @require_auth
    def __cmd_info__(self, event):
        '''
            Someone wants our info
        '''
        pass

    @require_auth
    def __cmd_authenticate__(self, event):
        '''
            Add a pubkey if someone we trust says its ok
        '''
        friend_pk = event.params['friend_pk']
        self.__authenticated_friends__.add(friend_pk)
        self.add_friend(friend_pk)
 
class PrimaryBot(ToxBase):
    '''
        Primary tox node:
        - create group chat
        - hand off on shutdown
        - Inherited base functions
    '''
    
    def __init__(self, data=None):
        self.primary = True
        super(PrimaryBot, self).__init__(data)
        
        # event handlers 
        self.router.register('fs_event', self.__cmd_fs_event__)
        self.router.register('info', self.__cmd_info__)
        self.router.register('primary', self.__cmd_primary__)
        self.router.register('authenticate', self.__cmd_authenticate__)
        self.router.register('join_chat', self.__cmd_join_chat__)
        
        # group chat room
        self.base_group_id = self.add_groupchat()

    def on_dht_connected(self):
        print('DHT Connected')
        self.set_user_status(Tox.USERSTATUS_NONE)
    
    def stop(self):
        super(PrimaryBot, self).stop()
    
    @require_auth
    def __cmd_fs_event__(self, event):
        pass
    
    @require_auth
    def __cmd_primary__(self, event):
        '''
            Ignore, we are primary
        '''
        pass

    @require_auth
    def __cmd_info__(self, event):
        '''
            Someone wants our host info
        '''
        pass

    @require_auth
    def __cmd_join_chat__(self, event):
        '''
            Someone requested access to chat room
            - TODO: Verify that they haven't already joined
        '''
        self.invite_friend(event.params['friend_id'], self.base_group_id)

    def __cmd_authenticate__(self, event):
        '''
            TODO: implement tox authorization logic
        '''
        self.__authenticated_friends__.add(event.params['friend_id'])
        self.add_friend_norequest(event.params['friend_pk'])
        
