from queue import Queue
from warnings import warn
import traceback

import ujson

class EventError(Exception):
    pass

class Params(object):
    '''
        Useful class for managing parameters
    '''
    def __init__(self, data=None):
        self.data = data if data is not None else {}
        self.akeys = set()
        self.rkeys = set()
    
    def __repr__(self):
        ''' Fancy lookin repr '''
        try:
            return '<%s %s>' % (self.__class__.__name__, ', '.join(['%s:%s' % (k, v) for k, v in self.data.items()]))
        except TypeError as e:
            return super(Params, self).__repr__()

    def require(self, *keys):
        '''Require these keys'''
        self.rkeys.update(keys)
        return self

    def allow(self, *keys):
        '''Allow these keys'''
        self.akeys.update(keys)
        return self
            
    def val(self, key=None):
        '''get req/allow keys or key'''
        try:
            if key is not None:
                return self.data[key]
            if not self.akeys and not self.rkeys:
                return self.data
            result = {}
            for k in self.rkeys:
                result[k] = self.data[k]
            for k in self.akeys:
                if k in self.data:
                    result[k] = self.data[k]
            return result
        except KeyError as e:
            raise EventError
        except TypeError as e:
            raise EventError

    def get(self, key):
        ''' Instantiate new from data '''
        try:
            val = self.data[key]
        except KeyError as e:
            raise EventError
        except TypeError as e:
            raise EventError
        return Params(val)

class Event(Params):
    '''
        Events that are generated by EventHandler
    '''
    def __init__(self, name, data):
        super(Event, self).__init__(data)
        self.name = name
        self.status = 'ok'
        self.source = None
        self.reply_with = None
        self.error_with = None

    def serialize(self):
        return ujson.dumps({
            'command': self.name,
            'params': self.val()
        })

    def reply(self, status, data=None):
        if not self.reply_with:
            warn('No "reply_with" specified for: %s' % self.name)
            return
        e = Event('response', data)
        e.status = status
        self.reply_with(e)

class EventHandler(object):
    '''
        Listen for events and call registered functions
    '''
    def __init__(self, parent, queue=False):
        self.parent = parent
        self.__cmds__ = {}
        self.queue = Queue() if queue else None
    
    def call_event(self, name, reply=None, error=None, params=None):
        '''
            Call all functions for event name
        '''
        params = params
        event = Event(name, params)
        event.reply_with = reply
        event.error_with = error
        event.source = self.parent
        if self.queue:
            self.queue.put(event)
        else:
            self.dispatch(event)

    def commit(self):
        while True:
            try:
                self.dispatch(self.queue.get_nowait())
            except Empty as e:
                break

    def dispatch(self, event):
        funcs = self.__cmds__.get(event.name, None)
        if funcs is None:
            self.handler_missing(event)
            return False 
        try:
            for f in funcs:
                if f(event) == False:
                    return False
        except EventError as e:
            warn(traceback.format_exc())
            if event.error_with:
                event.error_with(e)
            return False
        return True

    def handler_missing(self, event):
        '''
            Method called when no registered handlers
        '''
        warn('Handler missing: %s' % event.name)
        #print('no handlers for %s' % event.name)

    def register(self, name, func):
        '''
            Register func as function to be called when 
            event name is called
        '''
        if name not in self.__cmds__:
            self.__cmds__[name] = []
        self.__cmds__[name].append(func)

