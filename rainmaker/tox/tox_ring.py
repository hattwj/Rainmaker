# stdlib imports
from __future__ import print_function
from warnings import warn
import json

# lib imports
from twisted.internet import reactor, defer
from twisted.internet.task import LoopingCall
from pytox import Tox, OperationFailedError

# local imports
import tox_env
import tox_errors

def parse(line):
    '''
        parse yaml input from tox client
    '''
    print(line)
    try:
        request = json.loads(line)
    except ValueError as e:
        raise tox_errors.ToxCommandError('Failed to parse request')
    if not isinstance(request, dict):
        raise tox_errors.ToxCommandError('Request not a dictionary')
    cmd = request.get('command', None)
    if cmd is None:
        raise tox_errors.ToxCommandError('No command given')
    params = request.get('params', {})
    if not isinstance(params, dict):
        raise tox_errors.ToxCommandError('Params not a dictionary')
    
    return [cmd, params]


class Event(object):
    '''
        Events that are generated by EventHandler
    '''
    def __init__(self, name, params, source=None):
        self.name = name
        self.source = source
        self.params = params

    def serialize(self):
        return json.dumps({
            'command': self.name,
            'params': self.params
        })

class EventHandler(object):
    '''
        Listen for events and call registered functions
    '''
    def __init__(self, parent):
        self.parent = parent
        self.__cmds__ = {}
    
    def call_event(self, name, params=None):
        '''
            Call all functions for event name
        '''
        params = {} if params is None else params
        event = Event(name, params, self.parent)
        funcs = self.__cmds__.get(name, None)
        if funcs is None:
            self.handler_missing(event)
            return False
        for f in funcs:
            if f(event) == False:
                return False
        return True

    def handler_missing(self, event):
        '''
            Method called when no registered handlers
        '''
        pass
        #print('no handlers for %s' % event.name)

    def register(self, name, func):
        '''
            Register func as function to be called when 
            name is called
        '''
        if name not in self.__cmds__:
            self.__cmds__[name] = []
        self.__cmds__[name].append(func)

class Timer(object):
    '''
        Generic timer that will run after timeout elapsed
    '''
    def __init__(self, timeout, func, loop=False):
        self.timeout = timeout
        self.func = func
        self.loop = loop
        self._timer = None
        self.ran = False

    @property
    def running(self):
        '''
            Is the timer running?
        '''
        return self._timer.active()

    def reset(self):
        '''
            Reset timer, restart if off
        '''
        self.off()
        self.on()
    
    def _run(self):
        '''
            Run the timer
        '''
        self.func()
        self.ran = True
        if self.loop:
            self.on()

    def on(self):
        '''
            Turn the timer on
        '''
        self._timer = reactor.callLater(self.timeout, self._run)

    def off(self):
        '''
            Turn the timer off
        '''
        if self._timer and self._timer.active():
            self._timer.cancel()

def require_auth(func):
    '''
        Event responder decorator to require auth
    '''
    def wrapper(self, event):
        friend_id = event.params.get('friend_id', None)
        if friend_id is None:
            raise tox_errors.ToxAuthorizationError()
        if friend_id not in self.__authenticated_friends__:
            raise tox_errors.ToxAuthorizationError()
        func(self, event)
    return wrapper

class RunLevel(object):
    '''
        Generic run_level for state machine
    '''
    def __init_vars__(self):
        '''
            Initialize vars
        '''
        self.running = False
        self.should_run = True
        self.should_wait = True
        self.valid = False
        self.action = None
        self.prev_action = None

    def __init__(self, name, startf, stopf, validf, timeout=30, rate=0.5):
        ''' 
            
        '''
        self.name = name 
        self.__start = startf
        self.__stop = stopf
        self.__valid = validf
        self.__init_vars__()
        self.timeout = timeout
        self.rate = rate
    
    @property
    def status_changed(self):
        '''
            Has status changed?
        '''
        return self.prev_action != self.action

    def loop(self):
        '''
            Do loop once and record result
        '''
        self.prev_action = self.action
        self.action = self.__loop__()
        return self.action

    def __loop__(self):
        '''
            Do loop once and return result
        '''
        if self.running and self.should_run:
            if self.valid:
                return StateMachine.DO_NEXT
            elif self.should_wait:
                return StateMachine.DO_WAIT
            else:
                self.restart()
                return StateMachine.DID_RESTART
        elif self.running and not self.should_run:
            self.stop()
            return StateMachine.DID_STOP
        elif not self.running and self.should_run:
            self.start()
            return StateMachine.DID_START
        else:
            return StateMachine.DID_NO_OP
    
    def restart(self):
        '''
            Restart level
        '''
        self.stop()
        return self.start()

    def start(self):
        '''
            Start level
        '''
        def _stop_waiting():
            self.should_wait = False
        self.should_wait = True
        self.__init_vars__()
        self.__start()
        # start timeout timer
        self.__timeout_timer = Timer(self.timeout, _stop_waiting)
        self.__timeout_timer.on()
        # start validity rate timer
        self.__rate_timer = Timer(self.rate, self.__is_valid__, loop=True) 
        self.__rate_timer.on()
        self.running = True

    def stop(self):
        '''
            Stop level
        '''
        self.__stop()
        self.__rate_timer.off()
        self.__timeout_timer.off()
        self.running = False

    def __is_valid__(self):
        '''
            Check for valid state
        '''
        self.valid = self.__valid()
        if self.valid and self.__timeout_timer.running:
            self.__timeout_timer.off()
        elif not self.valid and not self.__timeout_timer.running:
            self.__timeout_timer.on()
        return self.valid

class StateMachine(object):
    DID_NO_OP   = -1
    DID_STOP    = 0
    DID_START   = 1
    DO_WAIT     = 2
    DID_RESTART = 3
    DO_NEXT     = 4
    
    # Filter out these events
    IGNORES = [DID_NO_OP, DO_WAIT]#, DO_NEXT]

    ACTION_NAMES = {
        DID_NO_OP:    'ignoring' ,
        DID_STOP:     'stopping',
        DID_START:    'starting',
        DO_WAIT:      'lost',
        DID_RESTART:  'restarting',
        DO_NEXT:      'completed'
    }

    def __init__(self, wait_time=0.5):
        self.run_levels = []
        self.wait_time = wait_time
    
    @defer.inlineCallbacks
    def start(self):
        '''
            start state machine
        '''
        self.stopping = False
        self.do_next = True
        self.__start_loop = LoopingCall(self.__loop__) 
        yield self.__start_loop.start(self.wait_time)

    def __loop__(self):
        if self.stopping and not self.any_running:
            # were done
            self.__start_loop.stop()
            return
        self.do_next = not self.stopping
        for idx, run_level in enumerate(self.run_levels):
            run_level.should_run = self.do_next 
            action = run_level.loop()
            if run_level.status_changed and not self.level_filter(action):
                self.level_changed(run_level.name, run_level.action, run_level.prev_action)
            if action != self.DO_NEXT:
                self.do_next = False
                levels = []
                for jdx, level in enumerate(self.run_levels):
                    if jdx > idx and level.running:
                        levels.append(level)
                for level in reversed(levels):
                    level.should_run = False
                    level.loop()
                return
            else:
                self.do_next = True
    
    def level_filter(self, action):
        '''
            Override to change filter behavior
        '''
        return action in self.IGNORES

    def level_changed(self, name, action, prev_action):
        '''
            Override to receive level changed event
        '''
        print('%s %s' % (self.ACTION_NAMES[action], name))

    @property
    def any_running(self):
        '''
            Are any run_levels running?
        '''
        for level in self.run_levels:
            if level.running:
                return True
        return False

    def add(self, run_level):
        '''
           Add run Level 
        '''
        if not hasattr(run_level, 'should_run'):
            raise AttributeError('Not a run level')
        self.run_levels.append(run_level)

    def stop(self):
        '''
            signal stop
        '''
        self.stopping = True
    
class ToxBase(Tox):

    '''
        Base class with overrides/defaults for Tox
    '''

    running = False
    was_connected = False
    ever_connected = False

    def __init__(self, data=None):
        self.__authenticated_friends__ = set()
        Tox.__init__(self)
        if data:
            self.load(data)
        # events received from tox client
        self.router = EventHandler(self)
        # events handler
        self.events = EventHandler(self)
        # connection state manager
        self.state_machine = StateMachine()
        self.state_machine.add(self.__conn_run_level__())
        self.start = self.state_machine.start
        self.stop = self.state_machine.stop
        self.state_machine.level_changed = self.state_level_changed
        self.router.register('ping', self.__cmd_ping__)

    def state_level_changed(self, name, code, prev_code):
        print('%s: %s %s' % (self.__class__.__name__, StateMachine.ACTION_NAMES[code], name)) 
        ename = '%s_%s' % (name, StateMachine.ACTION_NAMES[code])
        self.events.call_event(ename)

    def __conn_run_level__(self):
        from threading import Thread
        from time import sleep
        def _tox_do():
            # TODO: do_interval always returns 50
            #if self.do_interval() < 60:
            # rumored to be faster
            do = self.do
            while True:
                do()
                sleep(0.04)
                if not run_level.should_run:
                    break
        
        def _start():
            ip, port, pubk = tox_env.random_server()
            self.bootstrap_from_address(ip, port, pubk)
        
        def _stop():
            pass
            #timer.stop()
        
        def _valid():
            return self.isconnected()
        
        _tox_thread = Thread(target=_tox_do)
        _tox_thread.daemon = True
        _tox_thread.start()
        
        #timer = LoopingCall(_tox_do) 
        name = 'tox_connection'
        run_level = RunLevel(name, _start, _stop, _valid, 30)
        return run_level
          
    def on_read_reciept(self, fno, reciept):
        print('friend: %s recv: %s' % (fno, reciept))

    def on_dht_connected(self):
        print('dht-connnected-event')

    def on_dht_disconnected(self):
        print('dht-disconnected-event')

    def on_friend_request(self, pk, message):
        '''
            Pass to authenticate
        '''
        cmd, params = parse(message)
        params['friend_id'] = None
        params['friend_pk'] = pk
        cmd = 'authenticate'
        self.router.call_event(cmd, params)

    def on_friend_message(self, friend_id, message):
        '''
            A friend has sent a message
        '''
        cmd, params = parse(message)
        params['friend_id'] = friend_id
        self.router.call_event(cmd, params)

    def on_group_message(self, group_number, friend_id, message):
        '''
            A group member sent a message
        '''
        cmd, params = parse(message)
        params['friend_id'] = friend_id
        params['group_number'] = group_number
        self.router.call_event(cmd, params)

    def send_fs_event(self, event):
        '''
            Broadcast fs_event
        '''
        message = event.serialized_params()
        self.group_message_send(self.base_group_id, message)
        raise NotImplementedError('wip') 

    def __cmd_ping__(self, event):
        fid = event.params['friend_id']
        self.send_message(fid, {'cmd':'pong'})

class SyncBot(ToxBase):
    '''
        Find primary bot and relay information or bail
        if timeout reached
    '''
    def __init__(self, primary_address, data=None):
        ToxBase.__init__(self, data)
        self.router.register('fs_event', self.__cmd_fs_event__)
        self.router.register('info', self.__cmd_info__)
        self.router.register('authenticate', self.__cmd_authenticate__)
        self.router.register('primary', self.__cmd_primary__)
        self.primary = False
        self.primary_address = primary_address
        self.state_machine.add(self.__search_run_level__())

    def __search_run_level__(self):
        
        self.__search_tries_left = 2
        auth_msg = Event('authorize', {}).serialize()
        ping_msg = Event('ping', {}).serialize()
        
        # ran when level starts
        def _start():
            self.__search_tries_left -= 1
            if len(self.get_friendlist()) == 0:
                print('Adding primary')
                self.add_friend(self.primary_address, auth_msg)
        
        # ran when level stops
        def _stop():
            if self.__search_tries_left <= 0:
                self.state_machine.stop()
        
        # Periodic check to see if level is valid
        def _valid():

            if self.get_friend_connection_status(0):
                self.__search_tries_left = 2
                return True
            else:
                try:
                    # try to reach friends
                    for fid in self.get_friendlist():
                        self.send_message(fid, ping_msg)
                except OperationFailedError as e:
                    pass
                return False
        
        return RunLevel('tox_search', _start, _stop, _valid, 40)

    def on_group_invite(self, friend_num, gtype, grp_pubkey):
        print('Joining group: %s' % gtype)
        group_id = self.join_groupchat(friend_num, grp_pubkey)
         
    def on_start_primary(self, event):
        '''
            Overridden in tox_manager
        '''
        raise NotImplementedError('Override this method')
    
    @require_auth
    def __cmd_fs_event__(self, event):
        '''
            Someone had a file_system event
        '''
        pass
    
    @require_auth
    def __cmd_primary__(self, event):
        '''
            Someone thinks we should be primary
        '''
        pass

    @require_auth
    def __cmd_info__(self, event):
        '''
            Someone wants our info
        '''
        pass

    @require_auth
    def __cmd_authenticate__(self, event):
        '''
            Add a pubkey if someone we trust says its ok
        '''
        friend_pk = event.params['friend_pk']
        self.__authenticated_friends__.add(friend_pk)
        self.add_friend(friend_pk)
 
class PrimaryBot(ToxBase):
    '''
        Primary tox node:
        - create group chat
        - hand off on shutdown
        - Inherited base functions
    '''
    
    def __init__(self, data=None):
        self.primary = True
        super(PrimaryBot, self).__init__(data)
        
        # event handlers 
        self.router.register('fs_event', self.__cmd_fs_event__)
        self.router.register('info', self.__cmd_info__)
        self.router.register('primary', self.__cmd_primary__)
        self.router.register('authenticate', self.__cmd_authenticate__)
        self.router.register('join_chat', self.__cmd_join_chat__)
        
        # group chat room
        self.base_group_id = self.add_groupchat()

    def on_dht_connected(self):
        print('DHT Connected')
        self.set_user_status(Tox.USERSTATUS_NONE)
    
    def stop(self):
        super(PrimaryBot, self).stop()
    
    @require_auth
    def __cmd_fs_event__(self, event):
        pass
    
    @require_auth
    def __cmd_primary__(self, event):
        '''
            Ignore, we are primary
        '''
        pass

    @require_auth
    def __cmd_info__(self, event):
        '''
            Someone wants our host info
        '''
        pass

    @require_auth
    def __cmd_join_chat__(self, event):
        '''
            Someone requested access to chat room
            - TODO: Verify that they haven't already joined
        '''
        self.invite_friend(event.params['friend_id'], self.base_group_id)

    def __cmd_authenticate__(self, event):
        '''
            TODO: implement tox authorization logic
        '''
        self.__authenticated_friends__.add(event.params['friend_id'])
        self.add_friend_norequest(event.params['friend_pk'])
        
